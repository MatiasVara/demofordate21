/*
 * generated by Xtext 2.21.0
 */
package org.virtio.virtiodriver.ftracelanguage.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.virtio.virtiodriver.ftracelanguage.frtraceLanguage.Trace
import org.virtio.virtiodriver.ftracelanguage.frtraceLanguage.TraceModel

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class FrtraceLanguageGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		for (e : resource.allContents.toIterable.filter(TraceModel)) {
            fsa.generateFile(
               resource.URI.lastSegment +".extendedCCSL",
                e.compile)
        }
}	
	private def compile(TraceModel model)
	 '''
	ClockConstraintSystem Trace{
			imports {
			import "platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib" as lib0; 
			import "platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib" as lib1; 
		}
			entryBlock trace
			Block trace{
				Clock BaseTicks;
				«var linet = new line(1)»
				«FOR f : model.traces»
				        «f.compile(linet.counter)»
				        «linet.setCounter(linet.counter + 1)»
				 «ENDFOR»
				}
			}
	'''
	
	private def compile(Trace t, Integer line) '''
	Clock «t.name»;
	Sequence seqFor«t.name»:IntegerSequence = «line»(0);
	Expression «t.name»E=FilterBy( FilterByClock -> BaseTicks ,FilterBySeq -> seqFor«t.name»);
	Relation relation_«t.name»R[Coincides](   Clock2 -> «t.name»E,	Clock1 -> «t.name»  );
	'''
}

	class line {
		@Property
    	var int counter

    	new(int counter){
        	this.counter = counter
    	}
	}